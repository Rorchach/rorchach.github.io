[{"title":"HashSet","url":"/solid-octo-succotash/2023/05/20/HashSet/","content":"HashSet 是 Java 中的一个集合类，它实现了 Set 接口。HashSet 是基于哈希表（hash table）实现的，它使用哈希算法来存储和检索元素。\nHashSet 的特点包括：\n无序性： HashSet 不保持元素的特定顺序，存储和迭代元素的顺序是不确定的。\n唯一性：HashSet 不允许存储重复的元素。当尝试将重复的元素添加到 HashSet 中时，该操作会被忽略。\n高效性:HashSet 提供了快速的插入、删除和查找操作。这是因为它使用哈希算法将元素存储在内部的哈希表中，并根据元素的哈希值进行快速的索引和访问。\n使用 HashSet 时，要确保添加到集合中的元素正确实现了 hashCode() 和 equals() 方法。这两个方法在确定元素的哈希值和判断元素是否相等时起着关键作用。如果元素的哈希值发生冲突（即不同元素具有相同的哈希值），HashSet 会使用链表或红黑树等数据结构来解决冲突。\nHashSet 是常用的集合类之一，适用于需要存储唯一元素且不需要保持顺序的场景。它提供了高效的元素查找和插入操作，通常用于需要频繁地判断元素是否存在的场景。\n"},{"title":"Hello World","url":"/solid-octo-succotash/2023/05/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Markdown语法的简单笔记以及刷题复习java记录","url":"/solid-octo-succotash/2023/05/19/LeetCode%2001/","content":" 正文  # 换行，注意实际空一行，直接敲回车不能换行 代码块使用&#96;&#96;&#96;+编程语言 正文中的代码 hello world 直接用&#96;&#96;括住\n//给定整数 n ，返回 所有小于非负整数 n 的质数的数量public class demo1 &#123;    //定义一个使用筛法的计算小于n的质数数量的函数    public static int countPrimes(int n) &#123;        //初始化计数器为0        int count = 0;        //创建一个布尔数组，用于标记是否为质数        boolean[] prime = new boolean[n];        //将数组中所有元素设为true        for (int i = 2; i &lt; n; i++) &#123;            prime[i] = true;        &#125;        //遍历从2到n-1的所有整数，如果是质数，就将其倍数设为false        for (int i = 2; i &lt; n; i++) &#123;            if (prime[i]) &#123;                for (int j = i + i; j &lt; n; j += i) &#123;                    prime[j] = false;                &#125;            &#125;        &#125;        //遍历数组，统计true的个数，即质数的个数        for (int i = 0; i &lt; n; i++) &#123;            if (prime[i]) &#123;                count++;            &#125;        &#125;        //返回计数器的值        return count;    &#125;&#125;\n有序列表 数字+句点然后空格，可缩进\n\n123\n123\n123\n123\n123\n123\n\n\n\n\n\n\n\n无序列表，输入-，然后空格\n\n123\n123\n123\n\n\n\n\n\n加粗，倾斜加粗  使用两个前后括住倾斜       一个加粗倾斜  三个前后括住\n\n\ntitle:  217.”存在重复元素”（”Contains Duplicate”）问题题目：给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。\n输入：nums = [1,2,3,1]  输出： true\n\n分析：题目要求判断一个整数数组中是否存在至少两个重复元素使用HashSet(HashSet内容详见另一篇笔记)来判断数组中是否存在重复的元素使用增强for循环（iter）对数组进行遍历，将数组中的每个元素假如HashSet中由于HashSet不允许包含重复的元素，使用if判断contains，如果元素已经存在HashSet中，则元素重复，返回true，否则返回false\n代码实现： \nimport java.util.HashSet;public class demo2 &#123;        public boolean containsDuplicate(int[] nums) &#123;            HashSet&lt;Integer&gt; numSet = new HashSet&lt;Integer&gt;();            for(int num : nums)&#123;                if(numSet.contains(num))&#123;                    return true;                &#125;                numSet.add(num);            &#125;            return false;        &#125;&#125;\n时间复杂度：O（n）空间复杂度：O（n）\n 比较简单的一道题目，纯粹当做复习java基础\n"},{"title":"springboot基础配置","url":"/solid-octo-succotash/2023/05/29/javaweb02/","content":"\n属性配置1.解决配置文件中所用属性过多造成的代码冗余，可读性下降针对上面的问题，使用属性配置格式\nSpringBoot提供了三种配置文件的格式：properties(传统格式)    &gt; yml(主流格式)   &gt; yaml(加载优先级)\n对于不同配置文件，相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\nyaml语法规则键值对：使用冒号（:）将键和值分隔，并使用空格进行缩进。\nkey: value    \n注释：使用井号（#）表示注释，# 后的内容将被忽略。#这是注释列表：使用连字符（-）表示列表项，并使用空格进行缩进。\n- item1  - item2\n嵌套结构：使用缩进来表示嵌套的键值对或列表。\nparent:  child1: value1  child2: value2\n多行字符串：使用 | 符号表示多行字符串块，保留换行符和缩进。\nkey: |  This is a  multiline  string.\n引用：使用 &amp; 符号创建引用标记，并使用 * 符号引用该标记。\nkey1: &amp;ref valuekey2: *ref\n\n字符串引号：可以使用单引号（’）或双引号（”）将字符串括起来。双引号支持转义序列，单引号内的内容视为字面值。\nkey1: &#x27;single-quoted string&#x27;key2: &quot;double-quoted string&quot;\n\n\n读取yaml单一属性数据及yaml文件中的变量引用使用@value读取单个数据，属性名引用方式:$(一级属性名，二级属性名…….)             \n使用${属性名}引用数据支持转义字符，需要使用双引号包裹\nlesson:SpringBoot                                                             server：                                    port：82    enterprise：                                  name：itcast    age：16                                  tel：3832042394                                subject：        -java                                     -前端                             -大数据                     \n@RestController@RequestMapping(&quot;/books&quot;)public class BookController&#123;  @Value(&quot;$&#123;lesson&#125;&quot;)  private String lessonName;  @Value(&quot;$&#123;server.port&#125;&quot;)  private int port  @Value(&quot;$&#123;enterprise.subject[1]&#125;&quot;)  private String[] subject_01;&#125;\n\n\n读取yaml全部属性数据（1）使用Environment对象封装全部配置信息（2）使用@Autowired自动装配数据到Environment对象中\n\n读取yaml引用类型属性数据，自定义对象封装指定数据1.使用@ConfigurationProperties注解绑定配置信息到封装类2.封装类需要定义为Spring管理的bean，否则无法进行属性注入\n"},{"title":"手工创建SpringBoot项目","url":"/solid-octo-succotash/2023/05/28/javaweb/","content":"\n步骤：   1.创建普通Maven工程2.继承spring-boot-starter-parent3.添加依赖spring-boot-starter-web4.制作引导类Application\n\nFile types 隐藏文件   Idea中隐藏指定文件或指定类型文件Setting -&gt;File Types -&gt; Ignore Files and Folders输入要隐藏的文件名，支持*号通配符回车确认添加\n\nparent：1.开发SpringBoot程序要继承spring-boot-starter-parent2.spring-boot-starter-parent中定义了若干个依赖管理3.继承parent模块可以避免多个依赖使用相同的技术时出现依赖版本冲突4.继承parent的形式也可以采用引入依赖的形式实现效果\n\nstarter:  springboot中常见项目名称，定义了当前项目使用的所有依赖坐标，已达到减少依赖配置的目的(简单来说就是starter使用的parent)\nparent：所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），已达到减少依赖冲突的目的Spring-boot-starter-parent各版本间存在着诸多坐标版本不同\n实际开发：使用任意坐标时，仅书写GAV中的G和V，V由SpringBoot提供，除非SpringBoot未提供对应版本V如发生坐标错误，再指定Version（要小心版本冲突）\n正因为有starter引入依赖坐标，使得springboot更加遍历：starter就是一个定义了若干依赖坐标的pom管理文件\n\n项目启动方式：引导类 SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean\n\n设计编程:简单来说，使用通用接口编程，而不要使用实现类编程 \n\n内嵌tomcat服务器1.内嵌tomcat服务器是SpringBoot辅助功能之一2.工作原理：将tomcat服务器作为对象运行，并将对象交给Spring容器管理.3.变更内嵌服务器是去除现有服务器，添加全新服务器\n\n内置服务器tomcat(默认): apache出品，粉丝多，应用面广jetty:  更轻量级，负载性能远不及tomcatundertow：负载性能勉强跑赢tomcat\n\nREST风格（Representational State Transfer）表现形式状态转换REST（Representational State Transfer）是一种设计风格和架构原则，用于构建分布式网络应用程序。它是一种简化和标准化的通信协议，基于HTTP协议，并借用了Web的基本特性。根据REST风格对于资源进行访问称为RESTful\n"},{"title":"自托管和托管平台的区别","url":"/solid-octo-succotash/2023/05/26/%E8%87%AA%E6%89%98%E7%AE%A1/","content":"自托管的优势：\n完全控制：您拥有对服务器环境和博客设置的完全控制权，可以自定义和配置各个方面。灵活性：您可以根据需要选择适合您的技术栈和工具，并自由扩展和定制您的博客。独立性：不依赖第三方托管平台，您可以自主决定服务器供应商、资源分配和博客运行环境。数据隐私：您拥有对博客数据的直接访问和控制，可以更好地保护用户数据和隐私。\n自托管的劣势：\n技术要求：需要具备一定的技术知识和管理能力来设置、配置和维护服务器和博客应用程序。资源需求：自行购买服务器空间或虚拟主机，并承担服务器维护、安全性和性能优化的责任。成本：自托管可能需要额外的成本，包括购买服务器、域名和SSL证书等。\n使用托管平台的优势：\n简便性：托管平台提供了易于使用的界面和工作流程，使您能够快速启动和管理博客，无需自行配置服务器环境。可靠性和稳定性：托管平台通常提供高可用性、备份和故障恢复等功能，以确保博客的可靠性和稳定性。无需技术知识：不需要深入了解服务器管理和维护的技术，即可开始使用和管理博客。社区和支持：托管平台通常有庞大的用户社区和技术支持团队，可以提供帮助和解决问题。\n使用托管平台的劣势：\n限制和约束：托管平台可能会有一些限制和约束，例如存储空间、带宽限制、自定义功能的限制等。依赖性：博客的可用性和功能依赖于托管平台的稳定性和运行状况。数据隐私：您的博客数据可能存储在托管平台的服务器上，您需要确保平台有良好的数据保护和隐私政策。\n"},{"title":"最近规划","url":"/solid-octo-succotash/2023/05/27/%E8%A7%84%E5%88%92/","content":"快期末了，准备开始复习了，英语，物理什么的，还是要复习的。再有就是该拾起来Spring全家桶了\n"}]